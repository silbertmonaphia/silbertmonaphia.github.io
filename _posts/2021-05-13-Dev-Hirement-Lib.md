---
published: false
category: Others
title: 开发招聘题库  
author: smona
date: '2021-05-13 21:49:47'
layout: post
---

- [题库标准](#题库标准)
- [数据结构和算法(待完善)](#数据结构和算法待完善)
- [编程语言(待完善)](#编程语言待完善)
- [操作系统](#操作系统)
- [网络](#网络)
- [数据库](#数据库)
- [系统设计(待完善)](#系统设计待完善)

### 题库标准
六个类目中随机挑选1-2题便可生成一个对基础考察全面的「后台工程师」笔试题，预估候选者实力把题目难度和题量的时间控制在40min以内，建议不超过12题，不少于5题，每个类目至少1题

挑选本题库题目的原则:
1.平时工作都会直接或者间接接触到
2.范围都是高频常见必备知识点，不会有太偏太冷的知识点
3.难度匹配我们团队当前技术水平

### 数据结构和算法(待完善)
一.PHP array底层实现？
Sorted HashTable(https://learnku.com/articles/33225)

二.PHP实现快速排序算法/二分查找？


### 编程语言(待完善)
一.设计原则S.O.L.I.D？设计原则和设计模式的关系？
关系:设计模式的本质是为了遵循设计原则，设计模式是设计原则的具体化表现形式

1.SRP	The Single Responsibility Principle	单一责任原则
让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。
如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

2.OCP	The Open Closed Principle	开放封闭原则
类应该对扩展开放，对修改关闭
继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

3.LSP	The Liskov Substitution Principle	里氏替换原则
类对象必须能够替换掉所有父类对象。
继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。
如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

4.ISP	The Interface Segregation Principle	接口分离原则
不应该强迫客户依赖于它们不用的方法。
因此使用多个专门的接口比使用单一的总接口要好。

5.DIP	The Dependency Inversion Principle	依赖倒置原则
高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象。
高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：
任何变量都不应该持有一个指向具体类的指针或者引用；
任何类都不应该从具体类派生；
任何方法都不应该覆写它的任何基类中的已经实现的方法。

### 操作系统
一.进程与线程的联系和区别？
- 调度
进程是具有一定独立功能的程序的一次运行活动，进程是资源拥有和分派的基本单位。
线程是进程的一个实体，是CPU调度和分派的基本单位。
- 并发性
同一个进程中的多个线程之间可以并发执行。
- 拥有资源
进程可以拥有资源，是系统中拥有资源的一个基本单位
线程自己不拥有系统资源，但可以访问其所属的进程的资源。
- 系统开销
在创建或撤销进程时，系统都要创建和回收进程控制块，分配或者回收资源。类似的，进程切换时也涉及到当前进程CPU环境的保存以及新被调度进程的CPU环境的设置。
创建和撤销线程时开销较小。切换线程时，由于线程都具有相应的地址空间，因此仅需保存少量寄存器内容即可

二.进程通信(IPC)的方式？
- 管道
管道是用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。
写进程以字符流的形式将大量的数据送入管道，读进程从管道中接收数据
- FIFO
也称为命名管道，去除了管道只能在父子进程中使用的限制
FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。
- 消息队列
进程间的通信以格式化的message为单位
相比于 FIFO，消息队列具有以下优点：
消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
- 共享存储
允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。
需要使用信号量用来同步对共享存储的访问。
多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。
- 信号量
它是一个计数器，用于为多个进程提供对共享数据对象的访问。
- 套接字
与其它通信机制不同的是，它可用于不同机器间的进程通信。

三.用户态与核心态？它们的区别？
进程的执行在系统上的两个级别：用户级和核心级，也称为用户态和系统态。
程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。
当进程发出系统调用申请的时候，会产生一个软中断。产生这个软中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。

那么用户态和核心态之间的区别是什么呢？用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址。某些机器指令是特权指令，在用户态下执行特权指令会引起错误

四.死锁？死锁的处理？
在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。所谓死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。

死锁处理:
1.鸵鸟策略
把头埋在沙子里，假装根本没发生问题。
因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。
当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

2.死锁检测与恢复
不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。
 - 检测
   - 「每种类型一个资源的死锁检测」
      每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
   - 「每种类型多个资源的死锁检测」
      每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。
如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。如果没有这样一个进程，算法终止。
 - 恢复
   - 利用抢占恢复
   - 利用回滚恢复
   - 通过杀死进程恢复

3.死锁预防
在程序运行之前预防发生死锁。
- 破坏互斥条件
  不容易达到
- 破坏占有和等待条件
第一种，不持有并等待，即如果一个进程一次请求获取不了所有资源，那么它不可占用任何资源，且释放掉它已经占有的资源
第二种，持有不等待，资源充足，只要申请求资源，就给其资源，不让它等待。
- 破坏不可抢占条件
如果一个进程所请求的资源被另一进程占有，使它可以抢占另一进程占有的资源。
- 破坏环路等待
给资源统一编号，对资源进行排序，进程只能按编号顺序来请求资源，即每个进程访问资源的顺序是固定的。

4.死锁避免
在程序运行时避免发生死锁。

### 网络
一.如何从外部判断一个机器的某个端口(比如5044)是否存活或者打开？
telnet host port

二.TCP vs UDP?
传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）

用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

三.TCP三次握手和四次挥手的原因？
第三次握手的原因:是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

四次挥手的原因:客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

四.为什么TCP是可靠的？
TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段

五.TCP中的TIME_WAIT状态？并发中大量的 TIME_WAIT 状态 TCP 连接存在，其本质原因是什么?
客户端接收到服务器端的 FIN 报文后进入TIME_WAIT状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由:
1.确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
2.等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

并发中大量的 TIME_WAIT 状态 TCP 连接存在是因为大量短连接存在。特别是 HTTP 请求中，如果 connection 头部取值被设置为 close 时，基本都由「服务端」发起主动关闭连接，而TCP 四次挥手关闭连接机制中，为了保证 ACK 重发和丢弃延迟数据，设置 time_wait 为 2 倍的 MSL(报文最大存活时间)

六.Ping使用哪个协议？原理是怎样的？为什么企业服务器一般会禁Ping？
Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

禁ping好处:一定程度上在互联网上隐藏自己防止一些批量扫描软件探测主机，减少被入侵的几率以及减少被DDOS的可能；
禁ping坏处:无法使用常用的ping或者监控软件来检测站点是否正常，服务器是否在线等；

### 数据库
一.关系型数据库的关系一般有哪几种？
一对一、一对多、多对多

一.事务和ACID？
事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

ACID？
1.A原子性（Atomicity）
事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2.C一致性（Consistency）
数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
3.I隔离性（Isolation）
一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4.D持久性（Durability）
一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：
只有满足一致性，事务的执行结果才是正确的。
在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
事务满足持久化是为了能应对系统崩溃的情况。

二.为什么MySQL显式不用`START TRANSACTION`就具备了事务特性？
AUTOCOMMIT，MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

三.隔离级别有哪些？
未提交读（READ UNCOMMITTED）
事务中的修改，即使没有提交，对其它事务也是可见的。

提交读（READ COMMITTED）
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可重复读（REPEATABLE READ）
保证在同一个事务中多次读取同一数据的结果是一样的。

可串行化（SERIALIZABLE）
强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。
该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

四.锁？

五.数据库设计的三范式和反范式化？
1NF: 是对属性的原子性，要求属性具有原子性，不可再分解
2NF: 是对记录的唯一性，要求记录有唯一标识，即实体的唯一性，即不存在部分依赖
3NF: 是对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖
反范式化:没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余，达到以空间换时间的目的。

六.多版本并发控制MVCC？
多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

七.下面SQL中关键字执行顺序？
```
SELECT COUNT(DISTINCT log_uuid)
FROM  shqz_login_role
JOIN shqz_create_role
ON shqz_login_role.udid = shqz_create_role.udid
WHERE log_ymd = 201905
GROUP BY  account_id 
HAVING COUNT(account_id) > 1
ORDER BY account_id
LIMIT 10
```
例如: SELECT => FROM => JOIN => ON => WHERE => GROUP BY => HAVING => ORDER BY => LIMIT
答案: from->on->join->where->group by（开始使用select中的别名，后面的语句中都可以使用别名）->sum、count、max、avg->having->select->distinct->order by->limit

八.索引实现中的B+树与红黑树的比较特点是什么？
红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

1.B+ 树有更低的树高
平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。
2.磁盘访问原理
操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。
如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。
B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。
3.磁盘预读特性
为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。

### 系统设计(待完善)
业务背景:
需求:
问题:
1.请针对上述需求进行抽象建模，最好画出数据库设计的ER 图和类对象设计的UML图
2.请针对上述需求进行接口的设计与拆分，最好给出相应的接口文档
3.请对1和2点中你作出的设计给出详细的估时以及理由
